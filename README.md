# Practice-Lab-Introduction-to-Kubernetes-Objects


Setup Environment
Open a terminal window using the menu: Terminal > New Terminal.

Note: If the terminal is already opened, please skip this step.



Step 1: Verify kubectl Version
Before proceeding, ensure that you have kubectl installed and properly configured. To check the version of kubectl, run the following command:

1
kubectl version

Copied!

Wrap Toggled!
You should see the following output, although the versions may be different:










Task 1: Create a Kubernetes Service using nginx image
A popular open-source web server, nginx is known for its high performance, stability, and low resource usage. It can also function as a reverse proxy, load balancer, and HTTP cache.

Creating a Kubernetes Service using an nginx image involves setting up a networking layer that allows other components within the Kubernetes cluster or external users to access the nginx application running in pods. To run nginx as a service in Kubernetes, you can follow these steps:

Create a Deployment named my-deployment1 using the nginx image
1
 kubectl create deployment my-deployment1 --image=nginx

Copied!

Wrap Toggled!


kubectl: The command-line tool for interacting with the Kubernetes API.

create deployment: Tells Kubernetes that you want to create a new Deployment. A Deployment is a Kubernetes object that manages a set of replicated Pods, ensuring that the specified number of replicas are running and updated.

my-deployment1: It is the name of the Deployment being created. In this case, the Deployment is named my-deployment1.

--image=nginx: It specifies the container image used for the Pods managed by this Deployment. The nginx image is a popular web server and reverse proxy server.

It creates a Deployment named my-deployment1 that uses the nginx image. Deployments manage the rollout and scaling of applications.

Expose the deployment as a service
1
  kubectl expose deployment my-deployment1 --port=80 --type=NodePort --name=my-service1

Copied!

Wrap Toggled!


It exposes the my-deployment1 Deployment as a Service named my-service1, making it accessible on port 80 through a NodePort. NodePort services allow external traffic to access the service.

Lists all services in the default namespace. Services provide a stable IP address and DNS name for accessing a set of pods.
1
 kubectl get services

Copied!

Wrap Toggled!


This command lists all the services in the default namespace, including nginx-service, and provides details such as the ClusterIP, NodePort, and target port.

By following these steps, you create a Kubernetes Service named nginx, which routes traffic to the nginx pods running in your cluster, making them accessible internally and externally via the assigned NodePort.
















Task 2: Manage Kubernetes Pods and Services
Get the list of pods
1
 kubectl get pods

Copied!

Wrap Toggled!


This command displays all pods, including those created by the my-deployment1 Deployment.

Show labels
Replace <pod-name> with the actual pod Name:

1
 kubectl get pod <pod-name> --show-labels

Copied!

Wrap Toggled!

This command will list the labels associated with the specified pod, helping you identify its attributes and categorization within your Kubernetes cluster.

Label the pod
Replace <pod-name> with the actual pod Name:

1
  kubectl label pods <pod-name> environment=deployment

Copied!

Wrap Toggled!


The command is used in Kubernetes to label a specific pod with the key-value pair environment=deployment. This label helps categorize and manage pods based on their deployment environment, making it easier to organize and select Kubernetes objects within the cluster.

Show labels
Replace <pod-name> with the actual pod Name:

1
 kubectl get pod <pod-name> --show-labels

Copied!

Wrap Toggled!


Run a test pod using the nginx image
1
  kubectl run my-test-pod --image=nginx --restart=Never

Copied!

Wrap Toggled!


This command tells Kubernetes to create a pod named "my-test-pod" using the nginx image, and the pod will not restart automatically if it stops for any reason as we are using --restart=Never.

Show logs
1
kubectl logs <pod-name>

Copied!

Wrap Toggled!
Replace <pod-name> with the actual name of the pod.



This command retrieves and displays the logs generated by the specified pod, allowing you to troubleshoot issues, monitor activity, and gather information about the pod's behavior.
















Task 3: Deploying a StatefulSet
A StatefulSet manages the deployment and scaling of a set of pods, and maintains a sticky identity for each of their Pods, ensuring that each Pod has a persistent identity and storage.

Create and open a file named statefulset.yaml in edit mode.
1
  touch statefulset.yaml

Copied!

Wrap Toggled!


Open statefulset.yaml, and add the following code, and save the file:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
   apiVersion: apps/v1
   kind: StatefulSet
   metadata:
     name: my-statefulset
   spec:
     serviceName: "nginx"
     replicas: 3
     selector:
       matchLabels:
         app: nginx
     template:
       metadata:
         labels:
           app: nginx
       spec:
         containers:
         - name: nginx
           image: nginx
           ports:
           - containerPort: 80
             name: web
     volumeClaimTemplates:
     - metadata:
         name: www
       spec:
         accessModes: [ "ReadWriteOnce" ]
         resources:
           requests:
             storage: 1Gi

Copied!

Wrap Toggled!
Explanation:
apiVersion: apps/v1 & kind: StatefulSet: Establishes that this resource is a StatefulSet, leveraging the stable, production‑ready apps/v1 API.

metadata.name: my-statefulset: Assigns a human‑readable identifier to the StatefulSet.

spec.serviceName: "nginx": Binds the StatefulSet to a headless Service named “nginx,” ensuring each pod has a stable network identity.

spec.replicas: 3: Orchestrates three pod replicas, each with its own persistent identity.

spec.selector.matchLabels: Directs the StatefulSet to manage pods labeled app: nginx.

spec.template: Defines the pod blueprint:

metadata.labels: app: nginx ensures new pods carry the matching label.
spec.containers configures the nginx container on port 80, named “web.”
volumeClaimTemplates: Automates the creation of a PersistentVolumeClaim named www for each replica, each requesting 1 Gi of storage with ReadWriteOnce access.

Apply the StatefulSet configuration.
1
   kubectl apply -f statefulset.yaml

Copied!

Wrap Toggled!
staefulsetapply.png

This command tells Kubernetes to create the resources defined in the YAML file.

Verify that the StatefulSet is created.
1
   kubectl get statefulsets

Copied!

Wrap Toggled!


After applying the StatefulSet, you should verify that the StatefulSet has been created and is running. This can be done using the kubectl get command.

By following these steps, you can successfully apply a StatefulSet in Kubernetes. The kubectl apply command is used to create the StatefulSet, and the kubectl get command helps you verify that the StatefulSet is running as expected.














Task 4: Implementing a DaemonSet
A DaemonSet ensures that a copy of a specific Pod runs on all (or some) nodes in the cluster. It is particularly useful for deploying system-level applications that provide essential services across the nodes in a cluster, such as log collection, monitoring, or networking services.

Create a file named daemonset.yaml and open it in edit mode:
1
  touch daemonset.yaml

Copied!

Wrap Toggled!


Create and open a file named daemonset.yaml in edit mode.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
  apiVersion: apps/v1
  kind: DaemonSet
  metadata:
    name: my-daemonset
  spec:
    selector:
      matchLabels:
        name: my-daemonset
    template:
      metadata:
        labels:
          name: my-daemonset
      spec:
        containers:
        - name: my-daemonset
          image: nginx

Copied!

Wrap Toggled!
Explanation
apiVersion: apps/v1 & kind: DaemonSet: Declares this resource as a DaemonSet under the stable apps/v1 API.

metadata.name: my-daemonset: Provides the DaemonSet’s unique name.

spec.selector.matchLabels: Targets pods labeled name: my-daemonset for scheduling.

spec.template.metadata.labels: Labels the pod template so it matches the selector.

spec.template.spec.containers: Defines a single container named my-daemonset using the nginx image.

Apply the DaemonSet
1
 kubectl apply -f daemonset.yaml

Copied!

Wrap Toggled!


This command tells Kubernetes to apply the configuration defined in the daemonset.yaml file. The apply command is used to create or update Kubernetes resources based on the configuration provided in the YAML file.

Verify that the DaemonSet has been created
1
   kubectl get daemonsets

Copied!

Wrap Toggled!


This output from kubectl get daemonsets provides information about the DaemonSet named "my-daemonset" in your Kubernetes cluster.

NAME: The name of the DaemonSet, which is "my-daemonset" in this case.

DESIRED: The desired number of DaemonSet pods. In your case, it's set to 7.

CURRENT: The current number of DaemonSet pods running. It shows 6 pods are currently running.

READY: The number of DaemonSet pods that are ready and available for use. All 6 running pods are ready.

UP-TO-DATE: The number of DaemonSet pods that are up-to-date with the latest configuration.

AVAILABLE: The number of DaemonSet pods that are available for use.

NODE SELECTOR: Specifies which nodes in the cluster the DaemonSet should run on. In this case, it's set to <none>, meaning the DaemonSet is not restricted to specific nodes.

AGE: The age of the DaemonSet, indicating how long it has been running.

Conclusion
Congratulations! You have completed the practice lab on Kubernetes. You created a Kubernetes Service, used various kubectl commands, deployed StatefulSets for stateful applications, and implemented DaemonSets for uniform pod deployment across cluster nodes.

Author(s)
